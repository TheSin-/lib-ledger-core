@import "amount.djinni"
@import "error.djinni"
@import "trust_level.djinni"

OperationOrderKey = enum {
    date;
    amount;
    senders;
    recipients;
    type;
    currency_name;
    fees;
    block_height;
}

# Type of operation.
#
# Itâ€™s possible to either send funds or receive ones.
OperationType = enum {
    send;
    receive;
}

#TODO
QueryFilter = interface +c {
    static accountEq(accountUid: string): QueryFilter;
    static accountNeq(accountUid: string): QueryFilter;
    static dateLte(time: date): QueryFilter;
    static dateLt(time: date): QueryFilter;
    static dateGt(time: date): QueryFilter;
    static dateGte(time: date): QueryFilter;
    static dateEq(time: date): QueryFilter;
    static dateNeq(time: date): QueryFilter;
    static containsRecipient(recipientAddress: string): QueryFilter;
    static containsSender(senderAddress: string): QueryFilter;
    static currencyEq(currencyName: string): QueryFilter;
    static operationUidEq(operationUid: string): QueryFilter;
    static operationUidNeq(operationUid: string): QueryFilter;
    static trustEq(trust: TrustLevel): QueryFilter;
    static trustNeq(trust: TrustLevel): QueryFilter;
    static feesEq(amount: Amount): QueryFilter;
    static feesNeq(amount: Amount): QueryFilter;
    static feesGte(amount: Amount): QueryFilter;
    static feesGt(amount: Amount): QueryFilter;
    static feesLte(amount: Amount): QueryFilter;
    static feesLt(amount: Amount): QueryFilter;
    static amountEq(amount: Amount): QueryFilter;
    static amountNeq(amount: Amount): QueryFilter;
    static amountGte(amount: Amount): QueryFilter;
    static amountGt(amount: Amount): QueryFilter;
    static amountLte(amount: Amount): QueryFilter;
    static amountLt(amount: Amount): QueryFilter;
    static blockHeightEq(blockHeight: i64): QueryFilter;
    static blockHeightNeq(blockHeight: i64): QueryFilter;
    static blockHeightGte(blockHeight: i64): QueryFilter;
    static blockHeightGt(blockHeight: i64): QueryFilter;
    static blockHeightLte(blockHeight: i64): QueryFilter;
    static blockHeightLt(blockHeight: i64): QueryFilter;
    static blockHeightIsNull(): QueryFilter;
    static operationTypeEq(operationType: OperationType): QueryFilter;
    static operationTypeNeq(operationType: OperationType): QueryFilter;

    op_and(filter: QueryFilter): QueryFilter;
    op_or(filter: QueryFilter): QueryFilter;
    op_and_not(filter: QueryFilter): QueryFilter;
    op_or_not(filter: QueryFilter): QueryFilter;
}

# Class respresenting a query for a set of operations.
OperationQuery = interface +c {
    # Apply given order to query's operation.
    # @param key, OperationOrderKey object which defines order
    # @param descending, bool
    # @return OperationQuery object, new ordered operation
    addOrder(key: OperationOrderKey, descending: bool): OperationQuery;

    # Get applied filter on operation query.
    # @return QueryFilter object
    filter(): QueryFilter;

    # Add offset to the operation query.
    # @param from, 64-bit integer
    offset(from: i64): OperationQuery;

    # Add limit to the operation query results.
    # @param count, 64-bit integer
    limit(count: i64): OperationQuery;

    #TODO
    # Complete the operation query.
    complete(): OperationQuery;

    #TODO
    partial(): OperationQuery;

    # Execute query to retrieve operations.
    # @param callback, if execute method succeed, return a list of Operation objects
    execute(callback: callback2<void, optional<list<Operation>>, optional<Error>>);
}
